import { put } from '@vercel/blob';
import { VoteRecord, GlobalRatingSnapshot } from './types.js';

const GLOBAL_SNAPSHOT_KEY = 'global/ratings-snapshot.json';

/**
 * Saves a vote using the Inbox Pattern.
 * 1. Appends to user's personal history file (sessions/{id}.json).
 * 2. Drops a ticket into the global inbox (inbox/{id}.json) for the Cron job.
 */
export async function saveVote(sessionId: string, winnerId: string, loserId: string) {
  const vote: VoteRecord = { winnerId, loserId, timestamp: Date.now() };

  // 1. Update Personal History
  const sessionKey = `sessions/${sessionId}.json`;
  let history: VoteRecord[] = [];
  
  try {
    const res = await fetch(`${process.env.BLOB_READ_URL}/${sessionKey}`, { cache: 'no-store' });
    if (res.ok) {
      history = await res.json();
    }
  } catch (e) {
    // File doesn't exist yet, start new history
  }

  history.push(vote);

  // 2. Generate unique key for Global Inbox to prevent overwrites
  const inboxKey = `inbox/${Date.now()}-${Math.random().toString(36).slice(2)}.json`;

  // Execute writes in parallel
  await Promise.all([
    // Update personal file (overwrite with new array)
    put(sessionKey, JSON.stringify(history), { 
      access: 'public', 
      addRandomSuffix: false,
      allowOverwrite: true
    }),
    
    // Drop into inbox
    put(inboxKey, JSON.stringify(vote), { access: 'public' })
  ]);
}

/**
 * Reads the pre-calculated global stats.
 * This file is generated by the Cron job.
 */
export async function getGlobalRatings(): Promise<GlobalRatingSnapshot> {
  try {
    const res = await fetch(`${process.env.BLOB_READ_URL}/${GLOBAL_SNAPSHOT_KEY}`, {
      next: { revalidate: 60 }
    } as any);
    
    if (!res.ok) throw new Error('No snapshot found');
    return await res.json();
  } catch (error) {
    return { updatedAt: Date.now(), ratings: {} };
  }
}

/**
 * Gets a user's raw vote history.
 */
export async function getUserHistory(sessionId: string): Promise<VoteRecord[]> {
  try {
    const res = await fetch(`${process.env.BLOB_READ_URL}/sessions/${sessionId}.json`, {
      cache: 'no-store'
    });
    if (!res.ok) return [];
    return await res.json();
  } catch (error) {
    return [];
  }
}